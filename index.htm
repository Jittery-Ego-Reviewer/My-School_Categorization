import React, { useState, useEffect, useRef } from 'react';
import { User, BookOpen, MapPin, Box, Monitor, Activity, Plus, Check, X, RotateCcw } from 'lucide-react';

// --- è³‡æ–™è¨­å®š ---
const CATEGORIES = [
  { id: 'people', name: 'äººç‰©', icon: User, color: 'bg-pink-100 border-pink-400 text-pink-800' },
  { id: 'subjects', name: 'ç§‘ç›®', icon: BookOpen, color: 'bg-blue-100 border-blue-400 text-blue-800' },
  { id: 'places', name: 'è¨­æ–½/åœ°æ–¹', icon: MapPin, color: 'bg-green-100 border-green-400 text-green-800' },
  { id: 'items', name: 'ç‰©å“', icon: Box, color: 'bg-yellow-100 border-yellow-400 text-yellow-800' },
  { id: 'appliances', name: 'é›»å™¨', icon: Monitor, color: 'bg-purple-100 border-purple-400 text-purple-800' },
  { id: 'activities', name: 'æ´»å‹•', icon: Activity, color: 'bg-orange-100 border-orange-400 text-orange-800' }
];

const INITIAL_WORDS_DATA = [
  // äººç‰©
  { text: 'è·å“¡', category: 'people' }, { text: 'æ ¡é•·', category: 'people' }, { text: 'å‰¯æ ¡é•·', category: 'people' },
  { text: 'è¨“å°ä¸»ä»»', category: 'people' }, { text: 'ç­ä¸»ä»»', category: 'people' }, { text: 'è€å¸«', category: 'people' },
  { text: 'å·¥å‹', category: 'people' }, { text: 'åŒå­¸', category: 'people' }, { text: 'é¢¨ç´€', category: 'people' },
  { text: 'å€¼æ—¥ç”Ÿ', category: 'people' }, { text: 'å­¸ç”Ÿ', category: 'people' },
  // ç§‘ç›®
  { text: 'ä¸­æ–‡', category: 'subjects' }, { text: 'è‹±æ–‡', category: 'subjects' }, { text: 'æ•¸å­¸', category: 'subjects' },
  { text: 'äººæ–‡', category: 'subjects' }, { text: 'ç§‘å­¸', category: 'subjects' }, { text: 'è¦–è¦ºè—è¡“', category: 'subjects' },
  { text: 'æ™®é€šè©±', category: 'subjects' }, { text: 'å®—æ•™', category: 'subjects' }, { text: 'éŸ³æ¨‚', category: 'subjects' },
  // è¨­æ–½/åœ°æ–¹
  { text: 'èª²å®¤', category: 'places' }, { text: 'èµ°å»Š', category: 'places' }, { text: 'æ“å ´', category: 'places' },
  { text: 'ç¦®å ‚', category: 'places' }, { text: 'éŸ³æ¨‚å®¤', category: 'places' }, { text: 'é›»è…¦å®¤', category: 'places' },
  { text: 'æ•™å“¡å®¤', category: 'places' }, { text: 'æ ¡å‹™è™•', category: 'places' }, { text: 'æ´—æ‰‹é–“', category: 'places' },
  { text: 'åœ–æ›¸é¤¨', category: 'places' }, { text: 'çª—é–€', category: 'places' }, { text: 'é»‘æ¿', category: 'places' },
  // ç‰©å“
  { text: 'ç²‰ç­†', category: 'items' }, { text: 'ç²‰æ“¦', category: 'items' },
  { text: 'é£¯ç®±', category: 'items' }, { text: 'ç­†è¢‹', category: 'items' }, { text: 'æ›¸åŒ…', category: 'items' },
  { text: 'èª²æœ¬', category: 'items' }, { text: 'æ´»åŠ›åˆé¤', category: 'items' }, { text: 'æ°´å£º', category: 'items' },
  // é›»å™¨
  { text: 'æŠ•å½±æ©Ÿ', category: 'appliances' }, { text: 'å†·æ°£æ©Ÿ', category: 'appliances' }, { text: 'é›»è…¦', category: 'appliances' },
  { text: 'æ»‘é¼ ', category: 'appliances' }, { text: 'éµç›¤', category: 'appliances' }, { text: 'é¢¨æ‰‡', category: 'appliances' },
  // æ´»å‹•
  { text: 'çœ‹åœ–æ›¸', category: 'activities' }, { text: 'åšåŠŸèª²', category: 'activities' }, { text: 'ä¸Šèª²', category: 'activities' },
  { text: 'åšæ‰‹å·¥', category: 'activities' }, { text: 'ç•«ç•«', category: 'activities' }, { text: 'å°ä¼‘', category: 'activities' },
  { text: 'å¤šå…ƒæ™ºèƒ½', category: 'activities' }, { text: 'æ’éšŠ', category: 'activities' }, { text: 'é»˜æ›¸', category: 'activities' },
  { text: 'æ¸¬é©—', category: 'activities' }, { text: 'å¯«å­—', category: 'activities' }, { text: 'å”±æ­Œ', category: 'activities' },
  { text: 'è€ƒè©¦', category: 'activities' }
];

// éš¨æ©Ÿæ‰“äº‚é™£åˆ—
const shuffleArray = (array) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

export default function App() {
  const [wordQueue, setWordQueue] = useState([]);
  const [activeWords, setActiveWords] = useState([]);
  const [placedWords, setPlacedWords] = useState({
    people: [], subjects: [], places: [], items: [], appliances: [], activities: []
  });
  
  const [dragInfo, setDragInfo] = useState(null);
  const [showAddModal, setShowAddModal] = useState(false);
  const [newWordText, setNewWordText] = useState('');
  const [newWordCategory, setNewWordCategory] = useState('people');
  
  const [feedback, setFeedback] = useState(null); // { message, type }
  const [animatingBox, setAnimatingBox] = useState(null);
  const [errorWordId, setErrorWordId] = useState(null);

  const containerRef = useRef(null);

  // åˆå§‹åŒ–éŠæˆ²
  const initGame = () => {
    const shuffled = shuffleArray(INITIAL_WORDS_DATA.map((w, i) => ({ ...w, id: `word_${i}` })));
    setWordQueue(shuffled.slice(5));
    setActiveWords(shuffled.slice(0, 5));
    setPlacedWords({ people: [], subjects: [], places: [], items: [], appliances: [], activities: [] });
    setFeedback(null);
  };

  useEffect(() => {
    initGame();
  }, []);

  // ç•¶æ¡Œé¢ä¸Šçš„è©èªæ¸…ç©ºæ™‚ï¼Œè‡ªå‹•è£œä¸Š 5 å€‹æ–°è©èª
  useEffect(() => {
    if (activeWords.length === 0 && wordQueue.length > 0) {
      const nextBatch = wordQueue.slice(0, 5);
      setActiveWords(nextBatch);
      setWordQueue(wordQueue.slice(5));
    }
  }, [activeWords, wordQueue]);

  // --- æ‹–æ›³é‚è¼¯ (æ”¯æ´è§¸æ§èˆ‡æ»‘é¼ ) ---
  const handlePointerDown = (e, word) => {
    // å¿½ç•¥å³éµ
    if (e.button === 2) return;
    e.preventDefault();
    e.stopPropagation();

    const rect = e.currentTarget.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    setDragInfo({
      word,
      x: e.clientX,
      y: e.clientY,
      offsetX,
      offsetY,
      width: rect.width,
      height: rect.height
    });
  };

  const handlePointerMove = (e) => {
    if (!dragInfo) return;
    e.preventDefault();
    setDragInfo(prev => ({ ...prev, x: e.clientX, y: e.clientY }));
  };

  const handlePointerUp = (e) => {
    if (!dragInfo) return;

    // æš«æ™‚éš±è—æ‹–æ›³ä¸­çš„å…ƒç´ ï¼Œä»¥ä¾¿å–å¾—åº•ä¸‹çš„ç›®æ¨™ç‰©
    const dragElement = document.getElementById('drag-overlay');
    if (dragElement) dragElement.style.visibility = 'hidden';

    const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
    
    if (dragElement) dragElement.style.visibility = 'visible';

    const dropZone = elementBelow?.closest('[data-category]');

    if (dropZone) {
      const categoryId = dropZone.getAttribute('data-category');
      
      if (categoryId === dragInfo.word.category) {
        // åˆ†é¡æ­£ç¢º
        handleCorrectDrop(dragInfo.word, categoryId);
      } else {
        // åˆ†é¡éŒ¯èª¤
        handleWrongDrop(dragInfo.word);
      }
    }

    setDragInfo(null);
  };

  const handleCorrectDrop = (word, categoryId) => {
    // å¾ç¾ç”¨è©èªä¸­ç§»é™¤
    setActiveWords(prev => prev.filter(w => w.id !== word.id));
    // åŠ å…¥å°æ‡‰åˆ†é¡
    setPlacedWords(prev => ({
      ...prev,
      [categoryId]: [...prev[categoryId], word]
    }));
    
    // è¦–è¦ºå›é¥‹
    setAnimatingBox(categoryId);
    setTimeout(() => setAnimatingBox(null), 500);
  };

  const handleWrongDrop = (word) => {
    setErrorWordId(word.id);
    setTimeout(() => setErrorWordId(null), 500);
  };

  // --- æ–°å¢è©èªé‚è¼¯ ---
  const handleAddNewWord = (e) => {
    e.preventDefault();
    if (!newWordText.trim()) return;

    const newWord = {
      id: `new_${Date.now()}`,
      text: newWordText.trim(),
      category: newWordCategory
    };

    if (activeWords.length < 5 && wordQueue.length === 0) {
      setActiveWords(prev => [...prev, newWord]);
    } else {
      setWordQueue(prev => [...prev, newWord]);
    }

    setNewWordText('');
    setShowAddModal(false);
    
    setFeedback({ message: `å·²æˆåŠŸæ–°å¢è©èªï¼šã€Œ${newWord.text}ã€`, type: 'success' });
    setTimeout(() => setFeedback(null), 3000);
  };

  const isGameComplete = activeWords.length === 0 && wordQueue.length === 0;

  return (
    <div 
      ref={containerRef}
      className="min-h-screen bg-[#f0f9ff] font-sans flex flex-col touch-none select-none overflow-hidden"
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      onPointerLeave={handlePointerUp}
    >
      <style dangerouslySetInnerHTML={{__html: `
        @keyframes pop {
          0% { transform: scale(1); }
          50% { transform: scale(1.05); }
          100% { transform: scale(1); }
        }
        .animate-pop { animation: pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          20%, 60% { transform: translateX(-8px); }
          40%, 80% { transform: translateX(8px); }
        }
        .animate-shake { animation: shake 0.4s ease-in-out; }
        
        .drag-overlay {
          position: fixed;
          pointer-events: none;
          z-index: 9999;
          box-shadow: 0 10px 25px rgba(0,0,0,0.2);
          transform: scale(1.1) rotate(-3deg);
          transition: transform 0.1s;
        }
      `}} />

      {/* é ‚éƒ¨æ¨™é¡Œ */}
      <header className="bg-white shadow-sm py-4 px-6 flex justify-between items-center z-10 shrink-0">
        <h1 className="text-3xl font-bold text-sky-600 flex items-center gap-3">
          ğŸ« æˆ‘çš„æ ¡åœ’åˆ†é¡éŠæˆ²
        </h1>
        <div className="flex items-center gap-4">
          <div className="text-lg font-medium text-slate-600 bg-slate-100 px-4 py-2 rounded-full">
            é‚„æœ‰ <span className="text-sky-600 font-bold text-2xl">{wordQueue.length}</span> å€‹è©èª
          </div>
          <button 
            onClick={initGame}
            className="p-2 rounded-full hover:bg-slate-100 text-slate-500 transition-colors"
            title="é‡æ–°é–‹å§‹"
          >
            <RotateCcw size={24} />
          </button>
        </div>
      </header>

      {/* æç¤ºè¨Šæ¯ */}
      {feedback && (
        <div className="absolute top-20 left-1/2 -translate-x-1/2 z-50 bg-green-500 text-white px-6 py-3 rounded-full shadow-lg font-bold text-xl flex items-center gap-2 animate-bounce">
          <Check size={24} />
          {feedback.message}
        </div>
      )}

      {/* éŠæˆ²ä¸»è¦å€åŸŸ */}
      <main className="flex-1 flex flex-col p-4 md:p-6 gap-6 overflow-hidden h-full">
        
        {/* åˆ†é¡æ”¾ç½®å€ (ä¸ŠåŠéƒ¨) */}
        <div className="grid grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 flex-1 overflow-y-auto pb-4">
          {CATEGORIES.map(cat => {
            const Icon = cat.icon;
            const isAnimating = animatingBox === cat.id;
            
            return (
              <div 
                key={cat.id} 
                data-category={cat.id}
                className={`
                  border-4 rounded-3xl p-4 flex flex-col transition-all duration-300
                  ${cat.color} bg-opacity-40
                  ${isAnimating ? 'animate-pop border-green-500 ring-4 ring-green-300' : ''}
                  ${dragInfo ? 'border-dashed' : 'border-solid'}
                `}
              >
                <div className="flex items-center gap-3 mb-4 border-b-2 border-current pb-2 opacity-80">
                  <Icon size={28} className="drop-shadow-sm" />
                  <h2 className="text-2xl md:text-3xl font-black tracking-wide">{cat.name}</h2>
                  <span className="ml-auto bg-white bg-opacity-50 px-3 py-1 rounded-full text-lg font-bold">
                    {placedWords[cat.id].length}
                  </span>
                </div>
                
                <div className="flex flex-wrap gap-2 md:gap-3 content-start flex-1 overflow-y-auto">
                  {placedWords[cat.id].map(word => (
                    <div 
                      key={word.id} 
                      className="bg-white px-3 py-2 md:px-4 md:py-2 rounded-xl shadow-sm text-lg md:text-xl font-bold text-slate-700 border-2 border-opacity-20 border-current"
                    >
                      {word.text}
                    </div>
                  ))}
                  {placedWords[cat.id].length === 0 && (
                    <div className="w-full text-center text-current opacity-40 font-medium text-lg mt-4 border-2 border-dashed border-current rounded-xl py-4">
                      è«‹æŠŠè©èªæ‹‰åˆ°é€™è£¡
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        {/* è©èªåº« (ä¸‹åŠéƒ¨) */}
        <div className="h-48 md:h-56 bg-white rounded-3xl shadow-xl border-4 border-sky-200 p-4 md:p-6 flex flex-col shrink-0 relative">
          <div className="absolute -top-4 left-1/2 -translate-x-1/2 bg-sky-500 text-white px-6 py-1 rounded-full font-bold shadow-md">
            è©èªåº« (è«‹æ‹–æ›³åˆ°ä¸Šæ–¹çš„æ­£ç¢ºåˆ†é¡)
          </div>
          
          <div className="flex-1 flex justify-center items-center gap-4 md:gap-8 flex-wrap">
            {isGameComplete ? (
              <div className="text-3xl md:text-4xl font-black text-green-500 animate-bounce flex items-center gap-4">
                ğŸ‰ æ­å–œä½ ï¼å®Œæˆæ‰€æœ‰åˆ†é¡äº†ï¼ ğŸ‰
              </div>
            ) : (
              activeWords.map(word => {
                const isDragging = dragInfo?.word.id === word.id;
                const isError = errorWordId === word.id;
                
                return (
                  <div
                    key={word.id}
                    onPointerDown={(e) => handlePointerDown(e, word)}
                    className={`
                      px-6 py-4 md:px-8 md:py-5 rounded-2xl font-black text-2xl md:text-3xl
                      bg-yellow-300 text-yellow-900 border-b-8 border-yellow-500
                      cursor-grab active:cursor-grabbing hover:bg-yellow-200
                      transition-all
                      ${isDragging ? 'opacity-0' : 'opacity-100 shadow-lg hover:-translate-y-1 hover:shadow-xl'}
                      ${isError ? 'animate-shake bg-red-400 border-red-600 text-white' : ''}
                    `}
                    style={{ touchAction: 'none' }} // é‡è¦ï¼šé˜²æ­¢åœ¨å…ƒä»¶ä¸Šè§¸æ‘¸æ™‚ç™¼ç”Ÿæ²å‹•
                  >
                    {word.text}
                  </div>
                );
              })
            )}
          </div>

          {/* æ–°å¢æŒ‰éˆ• */}
          <button
            onClick={() => setShowAddModal(true)}
            className="absolute -right-2 -bottom-2 md:right-4 md:-bottom-6 bg-purple-500 hover:bg-purple-600 text-white p-4 rounded-full shadow-lg transition-transform hover:scale-110 flex items-center justify-center border-4 border-white"
            title="è€å¸«æ–°å¢è©èª"
          >
            <Plus size={32} strokeWidth={3} />
          </button>
        </div>

      </main>

      {/* æ‹–æ›³æ™‚çš„æ‡¸æµ®å…ƒç´  */}
      {dragInfo && (
        <div
          id="drag-overlay"
          className="drag-overlay bg-yellow-300 text-yellow-900 border-b-8 border-yellow-500 px-6 py-4 md:px-8 md:py-5 rounded-2xl font-black text-2xl md:text-3xl flex items-center justify-center"
          style={{
            left: dragInfo.x - dragInfo.offsetX,
            top: dragInfo.y - dragInfo.offsetY,
            width: dragInfo.width,
            height: dragInfo.height
          }}
        >
          {dragInfo.word.text}
        </div>
      )}

      {/* æ–°å¢è©èªå°è©±æ¡† (Teacher Tool) */}
      {showAddModal && (
        <div className="fixed inset-0 bg-slate-900 bg-opacity-50 z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-3xl shadow-2xl p-6 md:p-8 w-full max-w-md animate-pop">
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-bold text-slate-800 flex items-center gap-2">
                <Plus className="text-purple-500" /> åŠ å…¥æ–°è©èª
              </h2>
              <button 
                onClick={() => setShowAddModal(false)}
                className="p-2 bg-slate-100 hover:bg-slate-200 rounded-full text-slate-500"
              >
                <X size={24} />
              </button>
            </div>
            
            <form onSubmit={handleAddNewWord} className="space-y-6">
              <div>
                <label className="block text-lg font-bold text-slate-700 mb-2">è©èªåç¨±</label>
                <input
                  type="text"
                  value={newWordText}
                  onChange={(e) => setNewWordText(e.target.value)}
                  placeholder="ä¾‹å¦‚ï¼šåœ–æ›¸ç®¡ç†å“¡"
                  className="w-full text-2xl p-4 border-4 border-slate-200 rounded-2xl focus:border-purple-400 focus:outline-none transition-colors"
                  autoFocus
                />
              </div>
              
              <div>
                <label className="block text-lg font-bold text-slate-700 mb-2">é¸æ“‡æ­£ç¢ºçš„åˆ†é¡</label>
                <div className="grid grid-cols-2 gap-3">
                  {CATEGORIES.map(cat => (
                    <label 
                      key={cat.id}
                      className={`
                        flex items-center p-3 rounded-xl border-4 cursor-pointer transition-all
                        ${newWordCategory === cat.id ? 'border-purple-500 bg-purple-50' : 'border-slate-100 bg-slate-50 hover:bg-slate-100'}
                      `}
                    >
                      <input
                        type="radio"
                        name="category"
                        value={cat.id}
                        checked={newWordCategory === cat.id}
                        onChange={() => setNewWordCategory(cat.id)}
                        className="hidden"
                      />
                      <cat.icon size={20} className={`mr-2 ${newWordCategory === cat.id ? 'text-purple-600' : 'text-slate-500'}`} />
                      <span className={`font-bold text-lg ${newWordCategory === cat.id ? 'text-purple-700' : 'text-slate-600'}`}>
                        {cat.name}
                      </span>
                    </label>
                  ))}
                </div>
              </div>

              <button
                type="submit"
                disabled={!newWordText.trim()}
                className="w-full bg-purple-500 hover:bg-purple-600 disabled:bg-slate-300 disabled:cursor-not-allowed text-white font-bold text-2xl py-4 rounded-2xl shadow-lg transition-colors mt-4"
              >
                ç¢ºèªæ–°å¢
              </button>
            </form>
          </div>
        </div>
      )}

    </div>
  );
}
